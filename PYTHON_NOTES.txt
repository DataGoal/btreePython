PYTHON STRINGS

Strings in python are surrounded by either single quotation marks, or double quotation marks
'hello' is the same as "hello"
You can display a string literal with the print() function
print("Hello")
print('Hello')
-------------------------------------------------------------------------------
You can assign a multiline string to a variable by using three quotes
a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
print(a)
-------------------------------------------------------------------------------
Python does not have a character data type, a single character is simply a string with a length of 1
Square brackets can be used to access elements of the string
a = "Hello, World!"
print(a[1])
-------------------------------------------------------------------------------
we can loop through the characters in a string, with a for loop
for x in "banana":
  print(x)
-------------------------------------------------------------------------------
To check if a certain phrase or character is present in a string, we can use the keyword in
txt = "The best things in life are free!"
print("free" in txt)

with if,
txt = "The best things in life are free!"
if "free" in txt:
  print("Yes, 'free' is present.")
-------------------------------------------------------------------------------
To check if a certain phrase or character is NOT present in a string, we can use the keyword not in
txt = "The best things in life are free!"
print("expensive" not in txt)

with if,
txt = "The best things in life are free!"
if "expensive" not in txt:
  print("Yes, 'expensive' is NOT present.")
-------------------------------------------------------------------------------
SLICING STRINGS:

You can return a range of characters by using the slice syntax
Specify the start index and the end index, separated by a colon, to return a part of the string
b = "Hello, World!"
print(b[2:5])
-------------------------------------------------------------------------------
By leaving out the start index, the range will start at the first character
b = "Hello, World!"
print(b[:5])
-------------------------------------------------------------------------------
By leaving out the end index, the range will go to the end
b = "Hello, World!"
print(b[2:])
-------------------------------------------------------------------------------
Use negative indexes to start the slice from the end of the string
b = "Hello, World!"
print(b[-5:-2])
-------------------------------------------------------------------------------
PYTHON - MODIFY STRINGS

Python has a set of built-in methods that you can use on strings.

The upper() method returns the string in upper case
a = "Hello, World!"
print(a.upper())
-------------------------------------------------------------------------------
The lower() method returns the string in lower case
a = "Hello, World!"
print(a.lower())
-------------------------------------------------------------------------------
Whitespace is the space before and/or after the actual text, and very often you want to remove this space.
a = " Hello, World! "
print(a.strip()) # returns "Hello, World!"
-------------------------------------------------------------------------------
The replace() method replaces a string with another string
a = "Hello, World!"
print(a.replace("H", "J"))
-------------------------------------------------------------------------------
The split() method splits the string into substrings if it finds instances of the separator
a = "Hello, World!"
print(a.split(",")) # returns ['Hello', ' World!']
-------------------------------------------------------------------------------
PYTHON - FORMAT - STRINGS

In python, we cannot combine strings and numbers like this
age = 36
txt = "My name is John, I am " + age
print(txt)
-------------------------------------------------------------------------------
But we can combine strings and numbers by using the format() method!
The format() method takes the passed arguments, formats them, and places them in the string where the placeholders {} are:
Use the format() method to insert numbers into strings:
age = 36
txt = "My name is John, and I am {}"
print(txt.format(age))

The format() method takes unlimited number of arguments, and are placed into the respective placeholders:
quantity = 3
itemno = 567
price = 49.95
myorder = "I want {} pieces of item {} for {} dollars."
print(myorder.format(quantity, itemno, price))

You can use index numbers {0} to be sure the arguments are placed in the correct placeholders:
quantity = 3
itemno = 567
price = 49.95
myorder = "I want to pay {2} dollars for {0} pieces of item {1}."
print(myorder.format(quantity, itemno, price))
-------------------------------------------------------------------------------
PYTHON - ESCAPE CHARACTERS

To insert characters that are illegal in a string, use an escape character.
An escape character is a backslash \ followed by the character you want to insert.
An example of an illegal character is a double quote inside a string that is surrounded by double quotes:

txt = "We are the so-called "Vikings" from the north."

this will leads to error

txt = "We are the so-called \"Vikings\" from the north."
-------------------------------------------------------------------------------

ACCESS DICTIONARY ITEMS

Get the value of the "model" key:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
x = thisdict["model"]
x = thisdict.get("model")
-------------------------------------------------------------------------------
Get a list of the keys:

x = thisdict.keys()
-------------------------------------------------------------------------------

Add a new item to the original dictionary, and see that the keys list gets updated as well:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}
x = car.keys()
print(x) #before the change
car["color"] = "white"
print(x) #after the change
-------------------------------------------------------------------------------
Get a list of the values:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}
x = car.values()
print(x) #before the change
car["year"] = 2020
print(x) #after the change
-------------------------------------------------------------------------------
Add a new item to the original dictionary, and see that the values list gets updated as well:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.values()
print(x) #before the change
car["color"] = "red"
print(x) #after the change
-------------------------------------------------------------------------------
The items() method will return each item in a dictionary, as tuples in a list.

x = thisdict.items()
-------------------------------------------------------------------------------
Make a change in the original dictionary, and see that the items list gets updated as well:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.items()
print(x) #before the change
car["year"] = 2020
print(x) #after the change
-------------------------------------------------------------------------------
Add a new item to the original dictionary, and see that the items list gets updated as well:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.items()
print(x) #before the change
car["color"] = "red"
print(x) #after the change
-------------------------------------------------------------------------------
Check if "model" is present in the dictionary:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")


Change the "year" to 2018:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["year"] = 2018

-------------------------------------------------------------------------------
Update the "year" of the car by using the update() method:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"year": 2020})

Adding an item to the dictionary is done by using a new index key and assigning a value to it:
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["color"] = "red"
print(thisdict)

-------------------------------------------------------------------------------
The update() method will update the dictionary with the items from a given argument. If the item does not exist, the item will be added.

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"color": "red"})
-------------------------------------------------------------------------------

The pop() method removes the item with the specified key name:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)
-------------------------------------------------------------------------------
The popitem() method removes the last inserted item (in versions before 3.7, a random item is removed instead):

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.popitem()
print(thisdict)
-------------------------------------------------------------------------------
The del keyword removes the item with the specified key name:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
del thisdict["model"]
print(thisdict)
-------------------------------------------------------------------------------
The del keyword can also delete the dictionary completely:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
del thisdict
print(thisdict) #this will cause an error because "thisdict" no longer exists.
-------------------------------------------------------------------------------
The clear() method empties the dictionary:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.clear()
print(thisdict)
-------------------------------------------------------------------------------
Python - Loop Dictionaries
When looping through a dictionary, the return value are the keys of the dictionary, but there are methods to return the values as well.

Print all key names in the dictionary, one by one:
for x in thisdict:
  print(x)
-------------------------------------------------------------------------------
Print all values in the dictionary, one by one:

for x in thisdict:
  print(thisdict[x])
-------------------------------------------------------------------------------
You can also use the values() method to return values of a dictionary:

for x in thisdict.values():
  print(x)
-------------------------------------------------------------------------------
You can use the keys() method to return the keys of a dictionary:

for x in thisdict.keys():
  print(x)
-------------------------------------------------------------------------------
Loop through both keys and values, by using the items() method:

for x, y in thisdict.items():
  print(x, y)
-------------------------------------------------------------------------------
Python - Copy Dictionaries
You cannot copy a dictionary simply by typing dict2 = dict1, because: dict2 will only be a reference to dict1, and changes made in dict1 will automatically also be made in dict2.

There are ways to make a copy, one way is to use the built-in Dictionary method copy().
Make a copy of a dictionary with the copy() method:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = thisdict.copy()
print(mydict)
-------------------------------------------------------------------------------
Another way to make a copy is to use the built-in function dict().

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = dict(thisdict)
print(mydict)
-------------------------------------------------------------------------------
Nested Dictionaries
A dictionary can contain dictionaries, this is called nested dictionaries.

Create a dictionary that contain three dictionaries:
myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}
-------------------------------------------------------------------------------
Create three dictionaries, then create one dictionary that will contain the other three dictionaries:
child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}

myfamily = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}

print(myfamily)
{
   "child1":{
      "name":"Emil",
      "year":2004
   },
   "child2":{
      "name":"Tobias",
      "year":2007
   },
   "child3":{
      "name":"Linus",
      "year":2011
   }
}
-------------------------------------------------------------------------------
Python If ... Else

An "if statement" is written by using the if keyword.

a = 33
b = 200
if b > a:
  print("b is greater than a")
-------------------------------------------------------------------------------
The elif keyword is pythons way of saying "if the previous conditions were not true, then try this condition".

a = 33
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")
-------------------------------------------------------------------------------
The else keyword catches anything which isn't caught by the preceding conditions.

a = 200
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")
else:
  print("a is greater than b")

a = 200
b = 33
if b > a:
  print("b is greater than a")
else:
  print("b is not greater than a")
-------------------------------------------------------------------------------
If you have only one statement to execute, you can put it on the same line as the if statement.

if a > b: print("a is greater than b")
-------------------------------------------------------------------------------
Short Hand If ... Else

a = 2
b = 330
print("A") if a > b else print("B")
-------------------------------------------------------------------------------
We can also have multiple else statements on the same line, This technique is known as Ternary Operators, or Conditional Expressions.
One line if else statement, with 3 conditions:

print("A") if a > b else print("=") if a == b else print("B")
-------------------------------------------------------------------------------
The and keyword is a logical operator, and is used to combine conditional statements:

a = 200
b = 33
c = 500
if a > b and c > a:
  print("Both conditions are True")
-------------------------------------------------------------------------------
The or keyword is a logical operator, and is used to combine conditional statements:

a = 200
b = 33
c = 500
if a > b or a > c:
  print("At least one of the conditions is True")
-------------------------------------------------------------------------------
You can have if statements inside if statements, this is called nested if statements.

x = 41

if x > 10:
  print("Above ten,")
  if x > 20:
    print("and also above 20!")
  else:
    print("but not above 20.")
-------------------------------------------------------------------------------
if statements cannot be empty, but if you for some reason have an if statement with no content, put in the pass statement to avoid getting an error.

a = 33
b = 200

if b > a:
  pass
-------------------------------------------------------------------------------
The while Loop
With the while loop we can execute a set of statements as long as a condition is true.
Print i as long as i is less than 6:

i = 1
while i < 6:
  print(i)
  i += 1
-------------------------------------------------------------------------------
With the break statement we can stop the loop even if the while condition is true:

Exit the loop when i is 3:

i = 1
while i < 6:
  print(i)
  if i == 3:
    break
  i += 1
-------------------------------------------------------------------------------
With the continue statement we can stop the current iteration, and continue with the next:

Continue to the next iteration if i is 3:

i = 0
while i < 6:
  i += 1
  if i == 3:
    continue
  print(i)
-------------------------------------------------------------------------------
With the else statement we can run a block of code once when the condition no longer is true:

Print a message once the condition is false:

i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")
-------------------------------------------------------------------------------
Python For Loops

With the for loop we can execute a set of statements, once for each item in a list, tuple, set etc.

Print each fruit in a fruit list:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
-------------------------------------------------------------------------------
Even strings are iterable objects, they contain a sequence of characters:
Loop through the letters in the word "banana":

for x in "banana":
  print(x)
-------------------------------------------------------------------------------
With the break statement we can stop the loop before it has looped through all the items:
Exit the loop when x is "banana":

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break
-------------------------------------------------------------------------------
Exit the loop when x is "banana", but this time the break comes before the print:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    break
  print(x)
-------------------------------------------------------------------------------
With the continue statement we can stop the current iteration of the loop, and continue with the next:
Do not print banana:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)
-------------------------------------------------------------------------------
The range() Function
To loop through a set of code a specified number of times, we can use the range() function,
The range() function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and ends at a specified number.

Using the range() function:

for x in range(6):
  print(x)

Note that range(6) is not the values of 0 to 6, but the values 0 to 5.
The range() function defaults to 0 as a starting value, however it is possible to specify the starting value by adding a parameter: range(2, 6), which means values from 2 to 6 (but not including 6):

for x in range(2, 6):
  print(x)
-------------------------------------------------------------------------------
The range() function defaults to increment the sequence by 1, however it is possible to specify the increment value by adding a third parameter: range(2, 30, 3):

for x in range(2, 30, 3):
  print(x)
-------------------------------------------------------------------------------
Else in For Loop
The else keyword in a for loop specifies a block of code to be executed when the loop is finished:

Print all numbers from 0 to 5, and print a message when the loop has ended:

for x in range(6):
  print(x)
else:
  print("Finally finished!")
-------------------------------------------------------------------------------
Nested Loops
A nested loop is a loop inside a loop.
The "inner loop" will be executed one time for each iteration of the "outer loop":

Print each adjective for every fruit:

adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]

for x in adj:
  for y in fruits:
    print(x, y)
-------------------------------------------------------------------------------
The pass Statement
for loops cannot be empty, but if you for some reason have a for loop with no content, put in the pass statement to avoid getting an error.   

for x in [0, 1, 2]:
  pass
-------------------------------------------------------------------------------
PYTHON FUNCTIONS

Creating a Function
In Python a function is defined using the def keyword:

def my_function():
  print("Hello from a function")
-------------------------------------------------------------------------------
Calling a Function
To call a function, use the function name followed by parenthesis:

def my_function():
  print("Hello from a function")

my_function()
-------------------------------------------------------------------------------
Arguments
The following example has a function with one argument (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name:

def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")
-------------------------------------------------------------------------------
Number of Arguments
By default, a function must be called with the correct number of arguments. Meaning that if your function expects 2 arguments, you have to call the function with 2 arguments, not more, and not less.

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes")
-------------------------------------------------------------------------------
Arbitrary Arguments, *args
If you do not know how many arguments that will be passed into your function, add a * before the parameter name in the function definition.
This way the function will receive a tuple of arguments, and can access the items accordingly:
If the number of arguments is unknown, add a * before the parameter name:

def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus")
-------------------------------------------------------------------------------
Keyword Arguments
You can also send arguments with the key = value syntax.
This way the order of the arguments does not matter.

def my_function(child3, child2, child1):
  print("The youngest child is " + child3)

my_function(child1 = "Emil", child2 = "Tobias", child3 = "Linus")
-------------------------------------------------------------------------------
Arbitrary Keyword Arguments, **kwargs
If you do not know how many keyword arguments that will be passed into your function, add two asterisk: ** before the parameter name in the function definition.
This way the function will receive a dictionary of arguments, and can access the items accordingly:
If the number of keyword arguments is unknown, add a double ** before the parameter name:

def my_function(**kid):
  print("His last name is " + kid["lname"])

my_function(fname = "Tobias", lname = "Refsnes")
-------------------------------------------------------------------------------
Default Parameter Value
The following example shows how to use a default parameter value.
If we call the function without argument, it uses the default value:

def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")
-------------------------------------------------------------------------------
Passing a List as an Argument
You can send any data types of argument to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function.
E.g. if you send a List as an argument, it will still be a List when it reaches the function:

def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)
-------------------------------------------------------------------------------
Return Values
To let a function return a value, use the return statement:

def my_function(x):
  return 5 * x

print(my_function(3))
print(my_function(5))
print(my_function(9))
-------------------------------------------------------------------------------
The pass Statement
function definitions cannot be empty, but if you for some reason have a function definition with no content, put in the pass statement to avoid getting an error.

def myfunction():
  pass
-------------------------------------------------------------------------------
PYTHON LAMBDA

Add 10 to argument a, and return the result:

typical function,
def addTen (n):
    num = (n+10)
    return  num
print(addTen(5))

lambda function,
x = lambda a : a + 10
print(x(5))
-------------------------------------------------------------------------------
Multiply argument a with argument b and return the result:
-------------------------------------------------------------------------------
x = lambda a, b : a * b
print(x(5, 6))
-------------------------------------------------------------------------------
Summarize argument a, b, and c and return the result:
x = lambda a, b, c : a + b + c
print(x(5, 6, 2))

Why Use Lambda Functions?
The power of lambda is better shown when you use them as an anonymous function inside another function.
Say you have a function definition that takes one argument, and that argument will be multiplied with an unknown number:
Use that function definition to make a function that always doubles the number you send in:

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))
-------------------------------------------------------------------------------
for tripler,

def myfunc(n):
  return lambda a : a * n

mytripler = myfunc(3)

print(mytripler(11))
-------------------------------------------------------------------------------
function with both,

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))
-------------------------------------------------------------------------------
PYTHON SCOPE

Local Scope
A variable created inside a function is available inside that function:

def myfunc():
  x = 300
  print(x)

myfunc()
-------------------------------------------------------------------------------
The local variable can be accessed from a function within the function:

def myfunc():
  x = 300
  def myinnerfunc():
    print(x)
  myinnerfunc()

myfunc()
-------------------------------------------------------------------------------
A variable created outside of a function is global and can be used by anyone:

x = 300

def myfunc():
  print(x)

myfunc()

print(x)
-------------------------------------------------------------------------------
The function will print the local x, and then the code will print the global x:

x = 300

def myfunc():
  x = 200
  print(x)

myfunc()

print(x)
-------------------------------------------------------------------------------
If you use the global keyword, the variable belongs to the global scope:

def myfunc():
  global x
  x = 300

myfunc()

print(x)
-------------------------------------------------------------------------------
To change the value of a global variable inside a function, refer to the variable by using the global keyword:

x = 300

def myfunc():
  global x
  x = 200

myfunc()

print(x)
-------------------------------------------------------------------------------
Use end keyword in print function.
Usage of end, by default python’s print() function ends with a newline. Python’s print() function comes with a parameter called 'end'. By default, the value of this parameter is '\n', i.e. the new line character. You can modify a print statement with any character/string using this parameter.

print("Welcome to" , end = ' ') 
print("BtreeSystems", end = ' ')

above prints,

Welcome to BtreeSystems

instead of,

Welcome to
BtreeSystems

-------------------------------------------------------------------------------
PYTHON MODULES

To create a module just save the code you want in a file with the file extension .py
Save this code in a file named mymodule.py

def greeting(name):
  print("Hello, " + name)
-------------------------------------------------------------------------------
Now we can use the module we just created, by using the import statement:

import mymodule
mymodule.greeting("Jonathan")
-------------------------------------------------------------------------------
The module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc):
Save this code in the file mymodule.py

person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}
-------------------------------------------------------------------------------
Import the module named mymodule, and access the person1 dictionary:

import mymodule
a = mymodule.person1["age"]
print(a)
-------------------------------------------------------------------------------
You can create an alias when you import a module, by using the as keyword:
Create an alias for mymodule called mx:

import mymodule as mx
a = mx.person1["age"]
print(a)
-------------------------------------------------------------------------------
Built-in Modules
There are several built-in modules in Python, which you can import whenever you like.
Import and use the platform module:

import platform
x = platform.system()
print(x)
-------------------------------------------------------------------------------
Import From Module
You can choose to import only parts from a module, by using the from keyword.
The module named mymodule has one function and one dictionary:

def greeting(name):
  print("Hello, " + name)

person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}
-------------------------------------------------------------------------------
Import only the person1 dictionary from the module:

from mymodule import person1
print (person1["age"])
-------------------------------------------------------------------------------
PYTHON DATETIME
Import the datetime module and display the current date:

import datetime
x = datetime.datetime.now()
print(x)
2021-04-03 10:04:08.445075
-------------------------------------------------------------------------------
Return the year and name of weekday:
The datetime object has a method for formatting date objects into readable strings.
The method is called strftime(), and takes one parameter, format, to specify the format of the returned string:

import datetime
x = datetime.datetime.now()
print(x.year)
print(x.strftime("%A"))
print(x.strftime("%B"))
-------------------------------------------------------------------------------
Create a date object:

import datetime
x = datetime.datetime(2020, 5, 17)
print(x)
-------------------------------------------------------------------------------
A reference of all the legal format codes:
+-----------+-------------------------------------------------------------+--------------------------+
| Directive |                         Description                         |         Example          |
+-----------+-------------------------------------------------------------+--------------------------+
| %a        | Weekday, short version                                      | Wed                      |
| %A        | Weekday, full version                                       | Wednesday                |
| %w        | Weekday as a number 0-6, 0 is Sunday                        | 3                        |
| %d        | Day of month 01-31                                          | 31                       |
| %b        | Month name, short version                                   | Dec                      |
| %B        | Month name, full version                                    | December                 |
| %m        | Month as a number 01-12                                     | 12                       |
| %y        | Year, short version, without century                        | 18                       |
| %Y        | Year, full version                                          | 2018                     |
| %H        | Hour 00-23                                                  | 17                       |
| %I        | Hour 00-12                                                  | 5                        |
| %p        | AM/PM                                                       | PM                       |
| %M        | Minute 00-59                                                | 41                       |
| %S        | Second 00-59                                                | 8                        |
| %f        | Microsecond 000000-999999                                   | 548513                   |
| %z        | UTC offset                                                  | 100                      |
| %Z        | Timezone                                                    | CST                      |
| %j        | Day number of year 001-366                                  | 365                      |
| %U        | Week number of year, Sunday as the first day of week, 00-53 | 52                       |
| %W        | Week number of year, Monday as the first day of week, 00-53 | 52                       |
| %c        | Local version of date and time                              | Mon Dec 31 17:41:00 2018 |
| %x        | Local version of date                                       | 12/31/18                 |
| %X        | Local version of time                                       | 17:41:00                 |
| %%        | A % character                                               | %                        |
| %G        | ISO 8601 year                                               | 2018                     |
| %u        | ISO 8601 weekday (1-7)                                      | 1                        |
| %V        | ISO 8601 weeknumber (01-53)                                 | 1                        |
+-----------+-------------------------------------------------------------+--------------------------+
-------------------------------------------------------------------------------
PYTHON MATH
To use it, you must import the math module:

import math

The min() and max() functions can be used to find the lowest or highest value in an iterable:

x = min(5, 10, 25)
y = max(5, 10, 25)
print(x)
print(y)
-------------------------------------------------------------------------------
The abs() function returns the absolute (positive) value of the specified number:
x = abs(-7.25)

print(x)
-------------------------------------------------------------------------------
Return the value of 4 to the power of 3 (same as 4 * 4 * 4):

x = pow(4, 3)

print(x)
-------------------------------------------------------------------------------
The math.sqrt() method for example, returns the square root of a number:

import math

x = math.sqrt(64)

print(x)
-------------------------------------------------------------------------------
The math.ceil() method rounds a number upwards to its nearest integer, and the math.floor() method rounds a number downwards to its nearest integer, and returns the result:

import math
x = math.ceil(1.4)
y = math.floor(1.4)
print(x) # returns 2
print(y) # returns 1
-------------------------------------------------------------------------------
The math.pi constant, returns the value of PI (3.14...)

import math

x = math.pi

print(x)
-------------------------------------------------------------------------------
Math Methods:
+------------------+--------------------------------------------------------------------------------------------------------------+
|      Method      |                                                 Description                                                  |
+------------------+--------------------------------------------------------------------------------------------------------------+
| math.acos()      | Returns the arc cosine of a number                                                                           |
| math.acosh()     | Returns the inverse hyperbolic cosine of a number                                                            |
| math.asin()      | Returns the arc sine of a number                                                                             |
| math.asinh()     | Returns the inverse hyperbolic sine of a number                                                              |
| math.atan()      | Returns the arc tangent of a number in radians                                                               |
| math.atan2()     | Returns the arc tangent of y/x in radians                                                                    |
| math.atanh()     | Returns the inverse hyperbolic tangent of a number                                                           |
| math.ceil()      | Rounds a number up to the nearest integer                                                                    |
| math.comb()      | Returns the number of ways to choose k items from n items without repetition and order                       |
| math.copysign()  | Returns a float consisting of the value of the first parameter and the sign of the second parameter          |
| math.cos()       | Returns the cosine of a number                                                                               |
| math.cosh()      | Returns the hyperbolic cosine of a number                                                                    |
| math.degrees()   | Converts an angle from radians to degrees                                                                    |
| math.dist()      | Returns the Euclidean distance between two points (p and q), where p and q are the coordinates of that point |
| math.erf()       | Returns the error function of a number                                                                       |
| math.erfc()      | Returns the complementary error function of a number                                                         |
| math.exp()       | Returns E raised to the power of x                                                                           |
| math.expm1()     | Returns Ex - 1                                                                                               |
| math.fabs()      | Returns the absolute value of a number                                                                       |
| math.factorial() | Returns the factorial of a number                                                                            |
| math.floor()     | Rounds a number down to the nearest integer                                                                  |
| math.fmod()      | Returns the remainder of x/y                                                                                 |
| math.frexp()     | Returns the mantissa and the exponent, of a specified number                                                 |
| math.fsum()      | Returns the sum of all items in any iterable (tuples, arrays, lists, etc.)                                   |
| math.gamma()     | Returns the gamma function at x                                                                              |
| math.gcd()       | Returns the greatest common divisor of two integers                                                          |
| math.hypot()     | Returns the Euclidean norm                                                                                   |
| math.isclose()   | Checks whether two values are close to each other, or not                                                    |
| math.isfinite()  | Checks whether a number is finite or not                                                                     |
| math.isinf()     | Checks whether a number is infinite or not                                                                   |
| math.isnan()     | Checks whether a value is NaN (not a number) or not                                                          |
| math.isqrt()     | Rounds a square root number downwards to the nearest integer                                                 |
| math.ldexp()     | Returns the inverse of math.frexp() which is x * (2**i) of the given numbers x and i                         |
| math.lgamma()    | Returns the log gamma value of x                                                                             |
| math.log()       | Returns the natural logarithm of a number, or the logarithm of number to base                                |
| math.log10()     | Returns the base-10 logarithm of x                                                                           |
| math.log1p()     | Returns the natural logarithm of 1+x                                                                         |
| math.log2()      | Returns the base-2 logarithm of x                                                                            |
| math.perm()      | Returns the number of ways to choose k items from n items with order and without repetition                  |
| math.pow()       | Returns the value of x to the power of y                                                                     |
| math.prod()      | Returns the product of all the elements in an iterable                                                       |
| math.radians()   | Converts a degree value into radians                                                                         |
| math.remainder() | Returns the closest value that can make numerator completely divisible by the denominator                    |
| math.sin()       | Returns the sine of a number                                                                                 |
| math.sinh()      | Returns the hyperbolic sine of a number                                                                      |
| math.sqrt()      | Returns the square root of a number                                                                          |
| math.tan()       | Returns the tangent of a number                                                                              |
| math.tanh()      | Returns the hyperbolic tangent of a number                                                                   |
| math.trunc()     | Returns the truncated integer parts of a number                                                              |
+------------------+--------------------------------------------------------------------------------------------------------------+

Math Constants:
+----------+---------------------------------------------------+
| Constant |                    Description                    |
+----------+---------------------------------------------------+
| math.e   | Returns Euler's number (2.7182...)                |
| math.inf | Returns a floating-point positive infinity        |
| math.nan | Returns a floating-point NaN (Not a Number) value |
| math.pi  | Returns PI (3.1415...)                            |
| math.tau | Returns tau (6.2831...)                           |
+----------+---------------------------------------------------+

PYTHON FILE HANDLING

The key function for working with files in Python is the open() function.
The open() function takes two parameters; filename, and mode.
There are four different methods (modes) for opening a file:

"r" - Read - Default value. Opens a file for reading, error if the file does not exist
"a" - Append - Opens a file for appending, creates the file if it does not exist
"w" - Write - Opens a file for writing, creates the file if it does not exist
"x" - Create - Creates the specified file, returns an error if the file exists

In addition you can specify if the file should be handled as binary or text mode

"t" - Text - Default value. Text mode
"b" - Binary - Binary mode (e.g. images)
-------------------------------------------------------------------------------
To open a file for reading it is enough to specify the name of the file:

f = open("demofile.txt")
The code above is the same as:

f = open("demofile.txt", "rt")
Because "r" for read, and "t" for text are the default values, you do not need to specify them.
-------------------------------------------------------------------------------
demofile.txt
Hello! Welcome to demofile.txt
This file is for testing purposes.
Good Luck!

To open the file, use the built-in open() function.

The open() function returns a file object, which has a read() method for reading the content of the file:

f = open("C:\\Users\\bbhagy905\\Desktop\\BBC\\Python_BTree\\btreePython\\README.md", "r")
print(f.read())
-------------------------------------------------------------------------------
Read Only Parts of the File
By default the read() method returns the whole text, but you can also specify how many characters you want to return:

Return the 5 first characters of the file:

f = open("demofile.txt", "r")
print(f.read(5))
-------------------------------------------------------------------------------
Read Lines
You can return one line by using the readline() method:

Read one line of the file:

f = open("demofile.txt", "r")
print(f.readline())

By calling readline() two times, you can read the two first lines:

Read two lines of the file:

f = open("demofile.txt", "r")
print(f.readline())
print(f.readline())
-------------------------------------------------------------------------------
By looping through the lines of the file, you can read the whole file, line by line:

Loop through the file line by line:

f = open("C:\\Users\\bbhagy905\\Desktop\\BBC\\Python_BTree\\btreePython\\README.md", "r")
for x in f:
  print(x)
-------------------------------------------------------------------------------
Close Files
It is a good practice to always close the file when you are done with it.

Close the file when you are finish with it:

f = open("demofile.txt", "r")
print(f.readline())
f.close()  
-------------------------------------------------------------------------------
Write to an Existing File
To write to an existing file, you must add a parameter to the open() function:

"a" - Append - will append to the end of the file
"w" - Write - will overwrite any existing content

Open the file "demofile2.txt" and append content to the file:

f = open("demofile2.txt", "a")
f.write("Now the file has more content!")
f.close()

#open and read the file after the appending:
f = open("demofile2.txt", "r")
print(f.read())
-------------------------------------------------------------------------------
Open the file "demofile3.txt" and overwrite the content:

f = open("demofile3.txt", "w")
f.write("Woops! I have deleted the content!")
f.close()

#open and read the file after the appending:
f = open("demofile3.txt", "r")
print(f.read())
-------------------------------------------------------------------------------
Using write along with with() function

We can also use write function along with with() function:

# Python code to illustrate with() alongwith write()
with open("file.txt", "w") as f: 
    f.write("Hello World!!!") 
-------------------------------------------------------------------------------
split() using file handling

We can also split lines using file handling in Python. This splits the variable when space is encountered. You can also split using any characters as we wish. Here is the code:

# Python code to illustrate split() function
with open("file.text", "r") as file:
    data = file.readlines()
    for line in data:
        word = line.split(",")
        print (word)    
-------------------------------------------------------------------------------
#to read n no. of lines
with open("C:\\Users\\bbhagy905\\Desktop\\BBC\\Python_BTree\\btreePython\\README.md") as myfile:
    firstNlines=myfile.readlines()[0:5]
    print(firstNlines)       
-------------------------------------------------------------------------------
Create a New File
To create a new file in Python, use the open() method, with one of the following parameters:

"x" - Create - will create a file, returns an error if the file exist
"a" - Append - will create a file if the specified file does not exist
"w" - Write - will create a file if the specified file does not exist

Create a file called "myfile.txt":

f = open("myfile.txt", "x")
-------------------------------------------------------------------------------
Delete a File
To delete a file, you must import the OS module, and run its os.remove() function:

Remove the file "demofile.txt":

import os
os.remove("demofile.txt")
-------------------------------------------------------------------------------
Check if File exist:
To avoid getting an error, you might want to check if the file exists before you try to delete it:

Check if file exists, then delete it:

import os
if os.path.exists("demofile.txt"):
  os.remove("demofile.txt")
else:
  print("The file does not exist")
-------------------------------------------------------------------------------
Delete Folder
To delete an entire folder, use the os.rmdir() method:

Remove the folder "myfolder":

import os
os.rmdir("myfolder")  

-------------------------------------------------------------------------------

PYTHON REGEX

Import the re module:

import re

When you have imported the re module, you can start using regular expressions:
-------------------------------------------------------------------------------
Search the string to see if it starts with "The" and ends with "Spain":

import re

txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)

RegEx Functions
The re module offers a set of functions that allows us to search a string for a match:
+----------+-------------------------------------------------------------------+
| Function |                            Description                            |
+----------+-------------------------------------------------------------------+
| findall  | Returns a list containing all matches                             |
| search   | Returns a Match object if there is a match anywhere in the string |
| split    | Returns a list where the string has been split at each match      |
| sub      | Replaces one or many matches with a string                        |
+----------+-------------------------------------------------------------------+

Metacharacters
Metacharacters are characters with a special meaning:

+-----------+----------------------------------------------------------------------------+---------------+
| Character |                                Description                                 |    Example    |
+-----------+----------------------------------------------------------------------------+---------------+
| []        | A set of characters                                                        | "[a-m]"       |
| \         | Signals a special sequence (can also be used to escape special characters) | "\d"          |
| .         | Any character (except newline character)                                   | "he..o"       |
| ^         | Starts with                                                                | "^hello"      |
| $         | Ends with                                                                  | "world$"      |
| *         | Zero or more occurrences                                                   | "aix*"        |
| +         | One or more occurrences                                                    | "aix+"        |
| {}        | Exactly the specified number of occurrences                                | "al{2}"       |
| |         | Either or                                                                  | "falls|stays" |
| ()        | Capture and group                                                          |               |
+-----------+----------------------------------------------------------------------------+---------------+

Special Sequences
A special sequence is a \ followed by one of the characters in the list below, and has a special meaning:
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| Character | Description                                                                                                                                 | Example       |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \A        | Returns   a match if the specified characters are at the beginning of the string                                                            | "\AThe"       |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
|           | 	Returns a match where the   specified characters are at the beginning or at the end of a word                                             | r"\bain"      |  |  |
| \b        |      (the "r" in the beginning is making sure that the string is being   treated as a "raw string")                                         | r"ain\b"      |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
|           | Returns a match where the   specified characters are present, but NOT at the beginning (or at the end) of   a word                          | r"\Bain"      |  |  |
| \B        |      (the "r" in the beginning is making sure that the string is being   treated as a "raw string")                                         | r"ain\B"      |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \d        | 	Returns a match where the   string contains digits (numbers from 0-9)                                                                     | "\d"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \D        | Returns   a match where the string DOES NOT contain digits                                                                                  | "\D"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \s        | Returns   a match where the string contains a white space character                                                                         | "\s"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \S        | Returns a   match where the string DOES NOT contain a white space character                                                                 | "\S"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \w        | Returns a   match where the string contains any word characters (characters from a to Z,   digits from 0-9, and the underscore _ character) | "\w"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \W        | Returns a   match where the string DOES NOT contain any word characters                                                                     | "\W"          |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+
| \z        | Returns a   match if the specified characters are at the end of the string                                                                  | "Spain\Z"     |  |  |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------+---------------+--+--+


Sets
A set is a set of characters inside a pair of square brackets [] with a special meaning:
+------------+----------------------------------------------------------------------------------------------------------------------+
|    Set     |                                                     Description                                                      |
+------------+----------------------------------------------------------------------------------------------------------------------+
| [arn]      | Returns a match where one of the specified characters (a, r, or n) are present                                       |
| [a-n]      | Returns a match for any lower case character, alphabetically between a and n                                         |
| [^arn]     | Returns a match for any character EXCEPT a, r, and n                                                                 |
| [0123]     | Returns a match where any of the specified digits (0, 1, 2, or 3) are present                                        |
| [0-9]      | Returns a match for any digit between 0 and 9                                                                        |
| [0-5][0-9] | Returns a match for any two-digit numbers from 00 and 59                                                             |
| [a-zA-Z]   | Returns a match for any character alphabetically between a and z, lower case OR upper case                           |
| [+]        | In sets, +, *, ., |, (), $,{} has no special meaning, so [+] means: return a match for any + character in the string |
+------------+----------------------------------------------------------------------------------------------------------------------+

The findall() Function
The findall() function returns a list containing all matches.
Print a list of all matches:

import re

txt = "The rain in Spain"
x = re.findall("ai", txt)
print(x)
-------------------------------------------------------------------------------
The list contains the matches in the order they are found.
If no matches are found, an empty list is returned:

Return an empty list if no match was found:

import re

txt = "The rain in Spain"
x = re.findall("Portugal", txt)
print(x)
-------------------------------------------------------------------------------
The search() Function
The search() function searches the string for a match, and returns a Match object if there is a match.

If there is more than one match, only the first occurrence of the match will be returned:

Search for the first white-space character in the string:

  import re

  txt = "The rain in Spain"
  x = re.search("\s", txt)

  print("The first white-space character is located in position:", x.start())
-------------------------------------------------------------------------------
If no matches are found, the value None is returned:

Make a search that returns no match:

import re

txt = "The rain in Spain"
x = re.search("Portugal", txt)
print(x)
-------------------------------------------------------------------------------
The split() Function
The split() function returns a list where the string has been split at each match:

Split at each white-space character:

import re

txt = "The rain in Spain"
x = re.split("\s", txt)
print(x)
-------------------------------------------------------------------------------
You can control the number of occurrences by specifying the maxsplit parameter:

Split the string only at the first occurrence:

import re

txt = "The rain in Spain"
x = re.split("\s", txt, 1)
print(x)
-------------------------------------------------------------------------------
The sub() Function
The sub() function replaces the matches with the text of your choice:

Replace every white-space character with the number 9:

import re

txt = "The rain in Spain"
x = re.sub("\s", "9", txt)
print(x)
-------------------------------------------------------------------------------
You can control the number of replacements by specifying the count parameter:

Replace the first 2 occurrences:

import re

txt = "The rain in Spain"
x = re.sub("\s", "9", txt, 2)
print(x)
-------------------------------------------------------------------------------
Match Object
A Match Object is an object containing information about the search and the result.

Note: If there is no match, the value None will be returned, instead of the Match Object.

Do a search that will return a Match Object:

import re

txt = "The rain in Spain"
x = re.search("ai", txt)
print(x) #this will print an object
-------------------------------------------------------------------------------
The Match object has properties and methods used to retrieve information about the search, and the result:

.span() returns a tuple containing the start-, and end positions of the match.
.string returns the string passed into the function
.group() returns the part of the string where there was a match

Print the position (start- and end-position) of the first match occurrence.

The regular expression looks for any words that starts with an upper case "S":

import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.span())
-------------------------------------------------------------------------------
Print the string passed into the function:

import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.string)
-------------------------------------------------------------------------------
Print the part of the string where there was a match.

The regular expression looks for first occurence words that starts with an upper case "S":

import re

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.group())
-------------------------------------------------------------------------------
PYTHON CLASSES AND OBJECTS

Python is an object oriented programming language.
Almost everything in Python is an object, with its properties and methods.
A Class is like an object constructor, or a "blueprint" for creating objects.
To create a class, use the keyword class:
To understand the meaning of classes we have to understand the built-in __init__() function.
Use the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created
Objects can also contain methods. Methods in objects are functions that belong to the object

Create a Class
To create a class, use the keyword class:

Create a class named MyClass, with a property named x:

class MyClass:
  x = 5
-------------------------------------------------------------------------------
Create Object
Now we can use the class named MyClass to create objects:

Example
Create an object named p1, and print the value of x:

p1 = MyClass()
print(p1.x)
-------------------------------------------------------------------------------
The __init__() Function
The examples above are classes and objects in their simplest form, and are not really useful in real life applications.
To understand the meaning of classes we have to understand the built-in __init__() function.
All classes have a function called __init__(), which is always executed when the class is being initiated.
Use the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created:

Create a class named Person, use the __init__() function to assign values for name and age:

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age


p1 = Person("John", 36)

print(p1.name)
print(p1.age)

Note: The __init__() function is called automatically every time the class is being used to create a new object.
-------------------------------------------------------------------------------
Object Methods
Objects can also contain methods. Methods in objects are functions that belong to the object.

Let us create a method in the Person class:
Insert a function that prints a greeting, and execute it on the p1 object:

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name + "and my age is " + str(self.age))

p1 = Person("John", 36)
p1.myfunc()
-------------------------------------------------------------------------------

The self Parameter
The self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.

It does not have to be named self , you can call it whatever you like, but it has to be the first parameter of any function in the class:

Use the words mysillyobject and abc instead of self:

class Person:
  def __init__(mysillyobject, name, age):
    mysillyobject.name = name
    mysillyobject.age = age

  def myfunc(abc):
    print("Hello my name is " + abc.name)

p1 = Person("John", 36)
p1.myfunc()
-------------------------------------------------------------------------------
Modify Object Properties
You can modify properties on objects like this:

Example
Set the age of p1 to 40:

p1.age = 40
-------------------------------------------------------------------------------
Delete Object Properties
You can delete properties on objects by using the del keyword:

Example
Delete the age property from the p1 object:

del p1.age
-------------------------------------------------------------------------------
Delete Objects
You can delete objects by using the del keyword:

Example
Delete the p1 object:

del p1
-------------------------------------------------------------------------------
The pass Statement
class definitions cannot be empty, but if you for some reason have a class definition with no content, put in the pass statement to avoid getting an error.

Example
class Person:
  pass
-------------------------------------------------------------------------------
An Object is an instance of a Class.
A class is like a blueprint while an instance is a copy of the class with actual values.
Let's take example animal dog, it’s an actual dog, dogs have many attributes like breed, age, color etc.
You can have many dogs to create many different instances, but without the class as a guide, you would be lost, not knowing what information is required.

An object consists of :
State: It is represented by the attributes of an object. It also reflects the properties of an object.
Behavior: It is represented by the methods of an object. It also reflects the response of an object to other objects.
Identity: It gives a unique name to an object and enables one object to interact with other objects.

DECLARING OBJECTS (Also called instantiating a class)
When an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.

class Dog:
     
    # A simple class
    # attribute
    attr1 = "mammal"
    attr2 = "dog"
 
    # A sample method 
    def fun(self):
        print("I'm a", self.attr1)
        print("I'm a", self.attr2)
 
# Driver code
# Object instantiation
Rodger = Dog()
 
# Accessing class attributes
# and method through objects
print(Rodger.attr1)
Rodger.fun()

In the above example, an object is created which is basically a dog named Rodger. This class only has two class attributes that tell us that Rodger is a dog and a mammal.
-------------------------------------------------------------------------------
THE SELF
Class methods must have an extra first parameter in the method definition. We do not give a value for this parameter when we call the method, Python provides it.
If we have a method that takes no arguments, then we still have to have one argument.
This is similar to this pointer in C++ and this reference in Java.
When we call a method of this object as myobject.method(arg1, arg2), this is automatically converted by Python into MyClass.method(myobject, arg1, arg2) – this is all the special self is about.
-------------------------------------------------------------------------------
__init__ method
The __init__ method is similar to constructors in C++ and Java. Constructors are used to initializing the object’s state. Like methods, a constructor also contains a collection of statements(i.e. instructions) that are executed at the time of Object creation. It is run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object.

# A Sample class with init method
class Person:
   
    # init method or constructor 
    def __init__(self, name):
        self.name = name
   
    # Sample Method 
    def say_hi(self):
        print('Hello, my name is', self.name)
   
p = Person('Nikhil')
p.say_hi()
-------------------------------------------------------------------------------
CONSTRUCTORS IN PYTHON

Constructors are generally used for instantiating an object.The task of constructors is to initialize(assign values) to the data members of the class when an object of class is created.In Python the __init__() method is called the constructor and is always called when an object is created.

Types of constructors :

default constructor: The default constructor is simple constructor which doesn’t accept any arguments. It’s definition has only one argument which is a reference to the instance being constructed.
parameterized constructor: constructor with parameters is known as parameterized constructor.The parameterized constructor take its first argument as a reference to the instance being constructed known as self and the rest of the arguments are provided by the programmer.

Example of default constructor :

class btreesystems:
  
    # default constructor
    def __init__(self):
        self.btree = "btreesystems"
  
    # a method for printing data members
    def print_btree(self):
        print(self.btree)
  
  
# creating object of the class
obj = btreesystems()
  
# calling the instance method using the object obj
obj.print_btree()
-------------------------------------------------------------------------------
Example of parameterized constructor :

class Addition:
    first = 0
    second = 0
    answer = 0
      
    # parameterized constructor
    def __init__(self, f, s):
        self.first = f
        self.second = s
      
    def display(self):
        print("First number = " + str(self.first))
        print("Second number = " + str(self.second))
        print("Addition of two numbers = " + str(self.answer))
  
    def calculate(self):
        self.answer = self.first + self.second
  
# creating object of the class
# this will invoke parameterized constructor
obj = Addition(1000, 2000)
  
# perform Addition
obj.calculate()
  
# display result
obj.display()
-------------------------------------------------------------------------------
Inheritance in Python

Inheritance is the capability of one class to derive or inherit the properties from another class.
It represents real-world relationships well.
It provides reusability of a code. We don’t have to write the same code again and again. Also, it allows us to add more features to a class without modifying it.
It is transitive in nature, which means that if class B inherits from another class A, then all the subclasses of B would automatically inherit from class A.

# A Python program to demonstrate inheritance 
# Base or Super class. Note object in bracket.
# (Generally, object is made ancestor of all classes)
# In Python 3.x "class Person" is 
# equivalent to "class Person(object)"
class Person(object):
       
    # Constructor
    def __init__(self, name):
        self.name = name
   
    # To get name
    def getName(self):
        return self.name
   
    # To check if this person is an employee
    def isEmployee(self):
        return False
   
   
# Inherited or Subclass (Note Person in bracket)
class Employee(Person):
   
    # Here we return true
    def isEmployee(self):
        return True
   
# Driver code
emp = Person("Bala")  # An Object of Person
print(emp.getName(), emp.isEmployee())
   
emp = Employee("Raja") # An Object of Employee
print(emp.getName(), emp.isEmployee())
-------------------------------------------------------------------------------
Subclassing (Calling constructor of parent class) 
A child class needs to identify which class is its parent class. This can be done by mentioning the parent class name in the definition of the child class. 
Eg: class subclass_name (superclass_name): 

# Python code to demonstrate how parent constructors are called.
  
# parent class
class Person( object ):    
  
        # __init__ is known as the constructor         
        def __init__(self, name, idnumber):   
                self.name = name
                self.idnumber = idnumber
        def display(self):
                print(self.name)
                print(self.idnumber)
  
# child class
class Employee( Person ):           
        def __init__(self, name, idnumber, salary, post):
                self.salary = salary
                self.post = post
  
                # invoking the __init__ of the parent class 
                Person.__init__(self, name, idnumber) 
  
                  
# creation of an object variable or an instance
a = Employee('Rahul', 886012, 200000, "Intern")    
  
# calling a function of the class Person using its instance
a.display() 

‘a’ is the instance created for the class Person. It invokes the __init__() of the referred class. You can see ‘object’ written in the declaration of the class Person. In Python, every class inherits from a built-in basic class called ‘object’. The constructor i.e. the ‘__init__’ function of a class is invoked when we create an object variable or an instance of the class.

The variables defined within __init__() are called as the instance variables or objects. Hence, ‘name’ and ‘idnumber’ are the objects of the class Person. Similarly, ‘salary’ and ‘post’ are the objects of the class Employee. Since the class Employee inherits from class Person, ‘name’ and ‘idnumber’ are also the objects of class Employee.
If you forget to invoke the __init__() of the parent class then its instance variables would not be available to the child class. 
-------------------------------------------------------------------------------
Different forms of Inheritance: 
1. Single inheritance: When a child class inherits from only one parent class, it is called single inheritance. We saw an example above.
2. Multiple inheritance: When a child class inherits from multiple parent classes, it is called multiple inheritance. 
Unlike Java and like C++, Python supports multiple inheritance. We specify all parent classes as a comma-separated list in the bracket. 
3. Multilevel inheritance: When we have a child and grandchild relationship.
4. Hierarchical inheritance: More than one derived classes are created from a single base.
5. Hybrid inheritance: This form combines more than one form of inheritance. Basically, it is a blend of more than one type of inheritance.
-------------------------------------------------------------------------------

# Python program to demonstrate
# multiple inheritance
# Base class1
class Mother:
    mothername = ""
    def mother(self):
        print(self.mothername)
 
# Base class2
class Father:
    fathername = ""
    def father(self):
        print(self.fathername)
 
# Derived class
class Son(Mother, Father):
    def parents(self):
        print("Father :", self.fathername)
        print("Mother :", self.mothername)
 
# Driver's code
s1 = Son()
s1.fathername = "JACK"
s1.mothername = "JOE"
s1.parents()
-------------------------------------------------------------------------------
# Python program to demonstrate
# multilevel inheritance
 
# Base class
class Grandfather:
 
    def __init__(self, grandfathername):
        self.grandfathername = grandfathername
 
# Intermediate class
class Father(Grandfather):
    def __init__(self, fathername, grandfathername):
        self.fathername = fathername
 
        # invoking constructor of Grandfather class
        Grandfather.__init__(self, grandfathername)
 
# Derived class
class Son(Father):
    def __init__(self,sonname, fathername, grandfathername):
        self.sonname = sonname
 
        # invoking constructor of Father class
        Father.__init__(self, fathername, grandfathername)
 
    def print_name(self):
        print('Grandfather name :', self.grandfathername)
        print("Father name :", self.fathername)
        print("Son name :", self.sonname)
 
#  Driver code
s1 = Son('Prince', 'John', 'Mark')
print(s1.grandfathername)
s1.print_name()
-------------------------------------------------------------------------------
# Python program to demonstrate
# Hierarchical inheritance
# Base class

class Parent:
      def func1(self):
          print("This function is in parent class.")
 
# Derived class1
class Child1(Parent):
      def func2(self):
          print("This function is in child 1.")
 
# Derivied class2
class Child2(Parent):
      def func3(self):
          print("This function is in child 2.")
  
# Driver's code
object1 = Child1()
object2 = Child2()
object1.func1()
object1.func2()
object2.func1()
object2.func3()
-------------------------------------------------------------------------------
# Python program to demonstrate
# hybrid inheritance

class School:
     def func1(self):
         print("This function is in school.")
  
class Student1(School):
     def func2(self):
         print("This function is in student 1. ")
  
class Student2(School):
     def func3(self):
         print("This function is in student 2.")
  
class Student3(Student1, School):
     def func4(self):
         print("This function is in student 3.")
  
# Driver's code
object = Student3()
object.func1()
object.func2()
-------------------------------------------------------------------------------

Private members of parent class
We don’t always want the instance variables of the parent class to be inherited by the child class i.e. we can make some of the instance variables of the parent class private, which won’t be available to the child class. 
We can make an instance variable by adding double underscores before its name. For example,

# Python program to demonstrate private members
# of the parent class
class C(object):
       def __init__(self):
              self.c = 21
  
              # d is private instance variable 
              self.__d = 42    
class D(C):
       def __init__(self):
              self.e = 84
              C.__init__(self)
object1 = D()
  
# produces an error as d is private instance variable
print(object1.d) 

Since ‘d’ is made private by those underscores, it is not available to the child class ‘D’ and hence the error.
-------------------------------------------------------------------------------
ENCAPSULATION IN PYTHON

Protected members
Protected members (in C++ and JAVA) are those members of the class that cannot be accessed outside the class but can be accessed from within the class and its subclasses. To accomplish this in Python, just follow the convention by prefixing the name of the member by a single underscore “_”.

# Python program to
# demonstrate protected members 
# Creating a base class
class Base:
    def __init__(self):
         
        # Protected member
        self._a = 2
 
# Creating a derived class   
class Derived(Base):
    def __init__(self):
         
        # Calling constructor of
        # Base class
        Base.__init__(self)
        print("Calling protected member of base class: ")
        print(self._a)
 
obj1 = Derived()
         
obj2 = Base()
 
# Calling protected member
# Outside class will  result in
# AttributeError
print(obj2.a)
-------------------------------------------------------------------------------
Private members
Private members are similar to protected members, the difference is that the class members declared private should neither be accessed outside the class nor by any base class. In Python, there is no existence of Private instance variables that cannot be accessed except inside a class. However, to define a private member prefix the member name with double underscore “__”.

# Python program to
# demonstrate private members

# Creating a Base class
class Base:
    def __init__(self):
        self.a = "BtreeSystems"
        self.__c = "Computer"


# Creating a derived class
class Derived(Base):
    def __init__(self):
        # Calling constructor of
        # Base class
        Base.__init__(self)
        print("Calling private member of base class: ")
        print(self.__c)


# Driver code
obj1 = Base()
print(obj1.a)
#print(obj1.c)

obj2 = Derived()

# Uncommenting print(obj1.c) will
# raise an AttributeError

# Uncommenting obj2 = Derived() will
# also raise an AtrributeError as
# private member of base class
# is called inside derived class
-------------------------------------------------------------------------------
POLYMORPHISM IN PYTHON
The word polymorphism means having many forms. In programming, polymorphism means same function name (but different signatures) being uses for different types.

Example of inbuilt polymorphic functions :
# Python program to demonstrate in-built poly-
# morphic functions
# len() being used for a string
print(len("btreesystems"))
  
# len() being used for a list
print(len([10, 20, 30]))

Examples of used defined polymorphic functions :
# A simple Python function to demonstrate 
# Polymorphism
  
def add(x, y, z = 0): 
    return x + y+z
  
# Driver code 
print(add(2, 3))
print(add(2, 3, 4))
-------------------------------------------------------------------------------
Polymorphism with class methods:
Below code shows how python can use two different class types, in the same way. We create a for loop that iterates through a tuple of objects. Then call the methods without being concerned about which class type each object is. We assume that these methods actually exist in each class.

class India():
    def capital(self):
        print("New Delhi is the capital of India.")
  
    def language(self):
        print("Hindi is the most widely spoken language of India.")
  
    def type(self):
        print("India is a developing country.")
  
class USA():
    def capital(self):
        print("Washington, D.C. is the capital of USA.")
  
    def language(self):
        print("English is the primary language of USA.")
  
    def type(self):
        print("USA is a developed country.")
  
obj_ind = India()
obj_usa = USA()
for country in (obj_ind, obj_usa):
    country.capital()
    country.language()
    country.type()
-------------------------------------------------------------------------------
Polymorphism with Inheritance:
In Python, Polymorphism lets us define methods in the child class that have the same name as the methods in the parent class. In inheritance, the child class inherits the methods from the parent class. However, it is possible to modify a method in a child class that it has inherited from the parent class. This is particularly useful in cases where the method inherited from the parent class doesn’t quite fit the child class. In such cases, we re-implement the method in the child class. This process of re-implementing a method in the child class is known as Method Overriding.


class Bird:
  def intro(self):
    print("There are many types of birds.")
      
  def flight(self):
    print("Most of the birds can fly but some cannot.")
    
class sparrow(Bird):
  def flight(self):
    print("Sparrows can fly.")

#method Overriding      
class ostrich(Bird):
  def flight(self):
    print("Ostriches cannot fly.")
      
obj_bird = Bird()
obj_spr = sparrow()
obj_ost = ostrich()
  
obj_bird.intro()
obj_bird.flight()
  
obj_spr.intro()
obj_spr.flight()
  
obj_ost.intro()
obj_ost.flight()
-------------------------------------------------------------------------------
Polymorphism with a Function and objects:
It is also possible to create a function that can take any object, allowing for polymorphism. In this example, let’s create a function called “func()” which will take an object which we will name “obj”. Though we are using the name ‘obj’, any instantiated object will be able to be called into this function. Next, lets give the function something to do that uses the ‘obj’ object we passed to it. In this case lets call the three methods, viz., capital(), language() and type(), each of which is defined in the two classes ‘India’ and ‘USA’. Next, let’s create instantiations of both the ‘India’ and ‘USA’ classes if we don’t have them already. With those, we can call their action using the same func() function:

class India():
    def capital(self):
        print("New Delhi is the capital of India.")
   
    def language(self):
        print("Hindi is the most widely spoken language of India.")
   
    def type(self):
        print("India is a developing country.")
   
class USA():
    def capital(self):
        print("Washington, D.C. is the capital of USA.")
   
    def language(self):
        print("English is the primary language of USA.")
   
    def type(self):
        print("USA is a developed country.")
  
def func(obj):
    obj.capital()
    obj.language()
    obj.type()
   
obj_ind = India()
obj_usa = USA()
   
func(obj_ind)
func(obj_usa)
-------------------------------------------------------------------------------
CLASS OR STATIC VARIABLES IN PYTHON

All objects share class or static variables. An instance or non-static variables are different for different objects (every object has a copy). For example, let a Computer Science Student be represented by class CSStudent. The class may have a static variable whose value is “cse” for all objects. And class may also have non-static members like name and roll. In C++ and Java, we can use static keywords to make a variable a class variable. The variables which don’t have a preceding static keyword are instance variables. The Python approach is simple; it doesn’t require a static keyword. 

# Python program to show that the variables with a value 
# assigned in class declaration, are class variables
  
# Class for Computer Science Student
class CSStudent:
    stream = 'cse'                  # Class Variable
    def __init__(self,name,roll):
        self.name = name            # Instance Variable
        self.roll = roll            # Instance Variable
  
# Objects of CSStudent class
a = CSStudent('Bala', 1)
b = CSStudent('Raja', 2)
  
print(a.stream)
print(b.stream)
print(a.name)
print(b.name)
print(a.roll)
print(b.roll)
  
# Class variables can be accessed using class
# name also
print(CSStudent.stream) # prints "cse"
  
# Now if we change the stream for just a it won't be changed for b
a.stream = 'ece'
print(a.stream) # prints 'ece'
print(b.stream) # prints 'cse'
  
# To change the stream for all instances of the class we can change it directly from the class
CSStudent.stream = 'mech'
  
print(a.stream) # prints 'mech'
print(b.stream) # prints 'mech'
-------------------------------------------------------------------------------
PYTHON ITERATORS
An iterator is an object that contains a countable number of values.
An iterator is an object that can be iterated upon, meaning that you can traverse through all the values.
Technically, in Python, an iterator is an object which implements the iterator protocol, which consist of the methods __iter__() and __next__()
-------------------------------------------------------------------------------
Iterator vs Iterable
Lists, tuples, dictionaries, and sets are all iterable objects. They are iterable containers which you can get an iterator from.

All these objects have a iter() method which is used to get an iterator:

Return an iterator from a tuple, and print each value:

mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))
-------------------------------------------------------------------------------
Even strings are iterable objects, and can return an iterator:

Strings are also iterable objects, containing a sequence of characters:

mystr = "banana"
myit = iter(mystr)

print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
-------------------------------------------------------------------------------
Create an Iterator
To create an object/class as an iterator you have to implement the methods __iter__() and __next__() to your object.

As in the Python Classes/Objects chapter, all classes have a function called __init__(), which allows you to do some initializing when the object is being created.

The __iter__() method acts similar, you can do operations (initializing etc.), but must always return the iterator object itself.
The __next__() method also allows you to do operations, and must return the next item in the sequence.

Create an iterator that returns numbers, starting with 1, and each sequence will increase by one (returning 1,2,3,4,5 etc.):

class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    x = self.a
    self.a += 1
    return x

myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
-------------------------------------------------------------------------------
StopIteration
The example above would continue forever if you had enough next() statements, or if it was used in a for loop.

To prevent the iteration to go on forever, we can use the StopIteration statement.

In the __next__() method, we can add a terminating condition to raise an error if the iteration is done a specified number of times:

Example
Stop after 20 iterations:

class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self

  def __next__(self):
    if self.a <= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration

myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
  print(x)
-------------------------------------------------------------------------------
EXCEPTIONS IN PYTHON
Python has many built-in exceptions that are raised when your program encounters an error (something in the program goes wrong).

When these exceptions occur, the Python interpreter stops the current process and passes it to the calling process until it is handled. If not handled, the program will crash.

Exceptions are raised when the program is syntactically correct but the code resulted in an error. This error does not stop the execution of the program, however, it changes the normal flow of the program.
-------------------------------------------------------------------------------
For example, let us consider a program where we have a function A that calls function B, which in turn calls function C. If an exception occurs in function C but is not handled in C, the exception passes to B and then to A.

If never handled, an error message is displayed and our program comes to a sudden unexpected halt.
-------------------------------------------------------------------------------
Exceptions versus Syntax Errors:
Syntax errors occur when the parser detects an incorrect statement. Observe the following example:

print( 0 / 0 ))
# it will throw syntax error
-------------------------------------------------------------------------------
exception errors will occurs whenever syntactically correct Python code results in an error. 

print( 0 / 0)
#it will throw ZeroDivisionError: integer division or modulo by zero

Instead of showing the message exception error, Python details what type of exception error was encountered. In this case, it was a ZeroDivisionError. Python comes with various built-in exceptions as well as the possibility to create self-defined exceptions.
-------------------------------------------------------------------------------
BUILT-IN EXCEPTIONS:
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning

Raising an Exception
We can use raise to throw an exception if a condition occurs. The statement can be complemented with a custom exception.
If you want to throw an error when a certain condition occurs using raise, you could go about it like this:

x = 10
if x > 5:
    raise Exception('x should not exceed 5. The value of x was: {}'.format(x))

The program comes to a halt and displays our exception to screen, offering clues about what went wrong.
-------------------------------------------------------------------------------
The AssertionError Exception
Instead of waiting for a program to crash midway, you can also start by making an assertion in Python. We assert that a certain condition is met. If this condition turns out to be True, then that is excellent! The program can continue. If the condition turns out to be False, you can have the program throw an AssertionError exception.

In the following example, where it is asserted that the code will be executed on a Linux system:

import sys
assert ('linux' in sys.platform), "This code runs on Linux only."

If you run this code on a Linux machine, the assertion passes. If you were to run this code on a Windows machine, the outcome of the assertion would be False and the result would be the following:

Traceback (most recent call last):
  File "<input>", line 2, in <module>
AssertionError: This code runs on Linux only.

In this example, throwing an AssertionError exception is the last thing that the program will do. The program will come to halt and will not continue. What if that is not what you want?
-------------------------------------------------------------------------------
THE TRY AND EXCEPT BLOCK: HANDLING EXCEPTIONS
The try and except block in Python is used to catch and handle exceptions. Python executes code following the try statement as a “normal” part of the program. The code that follows the except statement is the program’s response to any exceptions in the preceding try clause.

As you saw earlier, when syntactically correct code runs into an error, Python will throw an exception error. This exception error will crash the program if it is unhandled. The except clause determines how your program responds to exceptions.

The following function can help you understand the try and except block:

You can give the function a try using the following code:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except:
    pass

The way you handled the error here is by handing out a pass. If you were to run this code on a Windows machine, you would get no output:    

You got nothing. The good thing here is that the program did not crash. But it would be nice to see if some type of exception occurred whenever you ran your code. To this end, you can change the pass into something that would generate an informative message, like so:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except:
    print('Linux function was not executed')

Now this code on a Windows machine prints:    

Linux function was not executed

When an exception occurs in a program running this function, the program will continue as well as inform you about the fact that the function call was not successful.

What you did not get to see was the type of error that was thrown as a result of the function call. In order to see exactly what went wrong, you would need to catch the error that the function threw.

The following code is an example where you capture the AssertionError and output that message to screen:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except AssertionError as error:
    print(error)
    print('The linux_interaction() function was not executed')

Running this function on a Windows machine outputs the following:

Function can only run on Linux systems.
The linux_interaction() function was not executed

The first message is the AssertionError, informing you that the function can only be executed on a Linux machine. The second message tells you which function was not executed.
-------------------------------------------------------------------------------
In the previous example, you called a function that you wrote yourself. When you executed the function, you caught the AssertionError exception and printed it to screen.

Here’s another example where you open a file and use a built-in exception:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    with open('file.log') as file:
        read_data = file.read()
except:
    print('Could not open file.log')

If file.log does not exist, this block of code will output the following:

Could not open file.log

This is an informative message, and our program will still continue to run. In the Python docs, you can see that there are a lot of built-in exceptions that you can use here. One exception described on that page is the following:

Exception FileNotFoundError

Raised when a file or directory is requested but doesn’t exist. Corresponds to errno ENOENT.

To catch this type of exception and print it to screen, you could use the following code:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    with open('file.log') as file:
        read_data = file.read()
except FileNotFoundError as fnf_error:
    print(fnf_error)

In this case, if file.log does not exist, the output will be the following:

[Errno 2] No such file or directory: 'file.log'
-------------------------------------------------------------------------------
You can have more than one function call in your try clause and anticipate catching various exceptions. A thing to note here is that the code in the try clause will stop as soon as an exception is encountered.

Warning: Catching Exception hides all errors…even those which are completely unexpected. This is why you should avoid bare except clauses in your Python programs. Instead, you’ll want to refer to specific exception classes you want to catch and handle.

Look at the following code. Here, you first call the linux_interaction() function and then try to open a file:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
    with open('file.log') as file:
        read_data = file.read()
except FileNotFoundError as fnf_error:
    print(fnf_error)
except AssertionError as error:
    print(error)
    print('Linux linux_interaction() function was not executed')

If the file does not exist, running this code on a Windows machine will output the following:

Function can only run on Linux systems.
Linux linux_interaction() function was not executed

Inside the try clause, you ran into an exception immediately and did not get to the part where you attempt to open file.log. Now look at what happens when you run the code on a Linux machine:

[Errno 2] No such file or directory: 'file.log'
-------------------------------------------------------------------------------
Here are the key takeaways:

A try clause is executed up until the point where the first exception is encountered.
Inside the except clause, or the exception handler, you determine how the program responds to the exception.
You can anticipate multiple exceptions and differentiate how the program should respond to them.
Avoid using bare except clauses.

-------------------------------------------------------------------------------
The else Clause
In Python, using the else statement, you can instruct a program to execute a certain block of code only in the absence of exceptions.

Look at the following example:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except AssertionError as error:
    print(error)
else:
    print('Executing the else clause.')

If you were to run this code on a Linux system, the output would be the following:

Doing something.
Executing the else clause.

Because the program did not run into any exceptions, the else clause was executed.

-------------------------------------------------------------------------------
You can also try to run code inside the else clause and catch possible exceptions there as well:

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)

If you were to execute this code on a Linux machine, you would get the following result:

Doing something.
[Errno 2] No such file or directory: 'file.log'

From the output, you can see that the linux_interaction() function ran. Because no exceptions were encountered, an attempt to open file.log was made. That file did not exist, and instead of opening the file, you caught the FileNotFoundError exception.
-------------------------------------------------------------------------------
Cleaning Up After Using finally
Imagine that you always had to implement some sort of action to clean up after executing your code. Python enables you to do so using the finally clause.

import sys
def linux_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    print('Doing something.')
try:
    linux_interaction()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('Cleaning up, irrespective of any exceptions.')

In the previous code, everything in the finally clause will be executed. It does not matter if you encounter an exception somewhere in the try or else clauses. Running the previous code on a Windows machine would output the following:

Function can only run on Linux systems.
Cleaning up, irrespective of any exceptions.
-------------------------------------------------------------------------------
PYTHON JSON

JSON is a syntax for storing and exchanging data.
JSON is text, written with JavaScript object notation.
Python has a built-in package called json, which can be used to work with JSON data.

json.loads() method will results the json to Python dictionary.

Example
Convert from JSON to Python:

import json

# some JSON:
x =  '{ "name":"John", "age":30, "city":"New York"}'
# parse x:
y = json.loads(x)
# the result is a Python dictionary:
print(y["age"])
-------------------------------------------------------------------------------
Convert from Python to JSON
Python object can be converted into a JSON string by using the json.dumps() method.

Example
Convert from Python to JSON:
import json
# a Python object (dict):
x = {
  "name": "John",
  "age": 30,
  "city": "New York"
}
# convert into JSON:
y = json.dumps(x)
# the result is a JSON string:
print(y)
-------------------------------------------------------------------------------
Order the Result
The json.dumps() method has parameters to order the keys in the result:

Example
Use the sort_keys parameter to specify if the result should be sorted or not:

json.dumps(x, indent=4, sort_keys=True)










